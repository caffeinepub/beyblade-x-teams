{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fix maximum call stack size exceeded error",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Identify and fix the infinite recursion or circular dependency causing the maximum call stack size exceeded error",
      "acceptanceCriteria": [
        "Application loads without throwing maximum call stack size exceeded errors",
        "All React components render successfully without infinite loops",
        "React Query hooks do not trigger infinite refetch cycles",
        "useCallback and useMemo dependencies are correctly specified to prevent unnecessary re-renders"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Fix circular query invalidation patterns in team-related mutations. Review all mutation onSuccess handlers to ensure they don't create cascading invalidations that trigger each other. Specifically check useCreateTeam, useJoinTeam, useLeaveTeam, useApproveJoinRequests, useDenyJoinRequests, and useRemoveMember mutations to prevent them from invalidating queries that would trigger other mutations' invalidations in a loop."
        },
        {
          "path": "frontend/src/pages/TeamDetailPage.tsx",
          "operation": "modify",
          "description": "Fix infinite loop issues in useMemo dependencies for isCurrentUserLeader and isCurrentUserMember calculations. Ensure dependency arrays are stable and don't change on every render. Review all useMemo and useCallback hooks to verify their dependencies don't create circular re-render loops. Particularly check if currentUser, teamData, or membership status changes are causing derived state to recalculate and trigger re-renders."
        },
        {
          "path": "frontend/src/components/auth/ProfileSetupModal.tsx",
          "operation": "modify",
          "description": "Review useCallback dependencies for handleSave to ensure the callback reference is stable and doesn't cause parent component re-renders that recreate the modal, which could contribute to stack overflow issues if the modal is conditionally rendered based on state that the callback modifies."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Review profile setup modal rendering logic and authentication state management to ensure no circular dependencies exist between user profile checks, authentication state, and modal visibility that could cause infinite re-render loops. Verify the showProfileSetup conditional logic doesn't create a state update loop."
        },
        {
          "path": "frontend/src/hooks/useCurrentUser.ts",
          "operation": "modify",
          "description": "Verify that useGetCallerUserProfile and useGetCallerUserRole hooks have proper enabled conditions and don't trigger unnecessary refetches that could cascade into other query invalidations. Ensure the isLoading and isFetched state calculations are stable and don't cause consuming components to re-render infinitely."
        },
        {
          "path": "frontend/src/components/layout/AppHeader.tsx",
          "operation": "modify",
          "description": "Review unread inbox badge counter and navigation menu state to ensure no infinite re-render loops exist. Check if inbox query refetches are triggering component updates that cause the query to refetch again."
        },
        {
          "path": "frontend/src/pages/InboxPage.tsx",
          "operation": "modify",
          "description": "Review message list rendering and mutation handlers (mark as read, delete, approve/deny join requests) to ensure they don't create query invalidation loops with the inbox query or team-related queries."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Review and fix circular dependencies in React Query hook invalidation patterns for team-related mutations",
      "acceptanceCriteria": [
        "Query invalidation after mutations does not create circular refetch loops",
        "Team data queries (useTeamQuery, useCurrentTeam, useMyTeams) do not trigger each other infinitely",
        "Mutation success handlers properly scope their invalidations to prevent cascading effects"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Audit all queryClient.invalidateQueries calls in mutation onSuccess handlers. Replace broad invalidation patterns (e.g., invalidating all 'teams' queries) with specific query key invalidations. For example, when approving a join request, only invalidate the specific team's data and the user's membership status, not all team-related queries. Add exact: true option where appropriate to prevent over-invalidation. Review the dependency chain: team mutations → team list queries → individual team queries → membership queries to break any circular patterns."
        },
        {
          "path": "frontend/src/hooks/useActor.ts",
          "operation": "modify",
          "description": "Review the query invalidation logic in the useEffect that runs when identity changes. Ensure it doesn't trigger cascading invalidations that cause components to unmount/remount in ways that recreate the actor and trigger the effect again."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Check TeamDetailPage component for infinite loop issues in useMemo dependencies",
      "acceptanceCriteria": [
        "TeamDetailPage renders without causing stack overflow",
        "useMemo hooks have stable dependency arrays that do not change on every render",
        "Derived state calculations do not trigger re-renders that recalculate themselves"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/TeamDetailPage.tsx",
          "operation": "modify",
          "description": "Fix useMemo dependency arrays for isCurrentUserLeader and isCurrentUserMember to ensure they use stable references. If currentUser or teamData objects are recreated on every render, extract only the primitive values needed (e.g., currentUser?.id, teamData?.leader) as dependencies instead of the full objects. Review all computed values (canManageTeam, canInitiateBattle, etc.) to ensure their dependency chains don't create loops. Consider using useRef for values that shouldn't trigger recalculation."
        },
        {
          "path": "frontend/src/pages/LeaderDashboardPage.tsx",
          "operation": "modify",
          "description": "Review any useMemo or useCallback hooks to ensure stable dependencies that don't cause infinite re-render loops when displaying team data or handling battle requests."
        }
      ]
    }
  ]
}